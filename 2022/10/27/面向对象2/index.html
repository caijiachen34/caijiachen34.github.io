<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="继承性面向对象的特征二：继承性 一.继承性的好处： ①减少了代码冗余，提高代码的复用性 ②便于功能的扩展 ③为之后的多态性使用，提供了前提 二.继承性的格式：   class A extends B&amp;#123;&amp;#125; ​	A:子类，派生类，subclass ​	B:父类，超类，基类，superclass ​	2.1体现：一旦子类A继承父类B后，子类A中就获取了父类B中声明的所有属性和方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象2">
<meta property="og:url" content="http://example.com/2022/10/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="继承性面向对象的特征二：继承性 一.继承性的好处： ①减少了代码冗余，提高代码的复用性 ②便于功能的扩展 ③为之后的多态性使用，提供了前提 二.继承性的格式：   class A extends B&amp;#123;&amp;#125; ​	A:子类，派生类，subclass ​	B:父类，超类，基类，superclass ​	2.1体现：一旦子类A继承父类B后，子类A中就获取了父类B中声明的所有属性和方法。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221027152820291.png">
<meta property="og:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221027224732342.png">
<meta property="og:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028162633457.png">
<meta property="og:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028184726322.png">
<meta property="og:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028184615339.png">
<meta property="article:published_time" content="2022-10-27T01:22:50.000Z">
<meta property="article:modified_time" content="2022-10-29T06:56:35.341Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JavaSe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221027152820291.png">

<link rel="canonical" href="http://example.com/2022/10/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>面向对象2 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象2
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-27 09:22:50" itemprop="dateCreated datePublished" datetime="2022-10-27T09:22:50+08:00">2022-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-29 14:56:35" itemprop="dateModified" datetime="2022-10-29T14:56:35+08:00">2022-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>面向对象的特征二：继承性</p>
<p>一.继承性的好处：</p>
<p>①减少了代码冗余，提高代码的复用性</p>
<p>②便于功能的扩展</p>
<p>③为之后的多态性使用，提供了前提</p>
<p>二.继承性的格式：<code>   class A extends B&#123;&#125;</code></p>
<p>​	A:子类，派生类，subclass</p>
<p>​	B:父类，超类，基类，superclass</p>
<p>​	2.1体现：一旦子类A继承父类B后，子类A中就获取了父类B中声明的所有属性和方法。</p>
<p>​	特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类的私有结构。只有因为封装性的影响，使得子类不能调用父类的结构而已。</p>
<p>​	2.2子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展。</p>
<p>三.Java中关于继承性的规定</p>
<p>1.一个类可以被多个子类继承</p>
<p>2.Java中类的单继承性：一个类只能有一个父类</p>
<p>3.子分类是相对的概念</p>
<p>4.子类直接继承的父类称为直接父类。间接继承的父类称为间接父类</p>
<p>5.子类继承父类以后，就获取的直接父类以及所有间接父类中声明的属性和方法</p>
<p>四.1.如果我们没有显式声明一个类的父类的话，则此类继承于java.lang.Object类</p>
<p>2.所有的Java类(除java.lang.Object类之外)都直接或间接的继承于java.lang.Object类</p>
<p>3.意味着，所有的Java类具有java.lang.Object类声明的功能</p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>1.重写：子类继承父类以后，可以对父类中<em><strong>同名同参数</strong></em>的方法进行覆盖操作。</p>
<p>2.应用2：重写以后，当创建子类对象后，通过子类对象调用父类中的<em><strong>同名同参数</strong></em>的方法时，实际执行的是子类重写父类的方法。</p>
<p>3.重写的规定</p>
<p>​	方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型&#123;</span><br><span class="line">	//方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	约定俗称：子类中叫重写的方法，父类中的叫被重写的方法	</p>
<p>​	①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p>
<p>​	②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
<p>​	*特殊情况：子类不能重写父类中声明为private权限的方法</p>
<p>​	③返回值类型：</p>
<p>​		&gt;父类被重写的方法的返回值都是void，则子类重写的方法的返回值的类型只能是void</p>
<p>​		&gt;父类被重写方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是<em><strong>A类或者A类的子类</strong></em></p>
<p>​		&gt;父类被重写方法的返回值类型是基本数据类型（如double），则子类重写的方法的返回值类型必须是相同的基本数据类型（如double）</p>
<p>​	④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<p>*子类和父类的同名同参数的方法要么声明为非static（考虑重写），要么都声明为static（不是重写）。</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><img src="/../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221027152820291.png" alt="image-20221027152820291"></p>
<p>不同包下的普通类（非子类）要使用其他类，不可以调用声明为private，缺省，protected权限的属性，方法</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><h4 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h4><p>​	①我们可以在子类的方法或构造器中。通过使用“super.属性”或“super.方法”的方式，显式调用父类中声明的属性或方法。但是，通常情况下，我们习惯<em><strong>省略</strong></em>“super.”</p>
<p>​	②特殊情况1：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显式使用“<em><strong>super.属性</strong></em>”的方式，表面调用的是父类中声明的属性。</p>
<p>​	③特殊情况2：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“<em><strong>super.方法</strong></em>”的方式，表面调用的是父类中被重写的方法。</p>
<h4 id="super调用构造器-难"><a href="#super调用构造器-难" class="headerlink" title="super调用构造器(难)"></a>super调用构造器(难)</h4><p>​	①我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的指定构造器</p>
<p>​	②<code>super(形参列表)</code>的使用，必须声明在子类构造器的首行</p>
<p>​	③我们在类的构造器中，针对于<code>this(形参列表)</code>或<code>super(形参列表)</code>只能二选一，不能同时出现</p>
<p>​	④在构造器的首行，没有显式的声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认使用的是父类中空参的构造器super()</p>
<p>​	⑤在类的多个构造器中，至少有一个类的构造器中使用了<code>super(形参列表)</code>，调用父类中的构造器</p>
<p>*this和super区别：①this调用本类重载的其他构造器</p>
<p>​								   ②super调用父类指定的构造器</p>
<p>子类对象实例化的全过程</p>
<p>1.从结果看：（继承性）</p>
<p>​		子类继承父类以后，就获取了父类中声明的属性或方法。</p>
<p>​		创建子类的对象，在堆空间中，就会加载所以父类中声明的属性（不会创建父类对象）。</p>
<p>2.从过程看</p>
<p>​		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所才看到内存中有父类中的结构，子类对象才可以考虑进行调用。</p>
<p>*明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
<p>​	</p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>①理解多态性：一个事物的多种形态。</p>
<p>②何为多态性：</p>
<p>​	对象的多态性：父类的引用指向子类的对象（或子类的对象赋值给父类的引用）</p>
<p>③多态的使用：虚拟方法的调用</p>
<p>​	有了对象的多态性后，我们在编译期间，只能调用父类中声明的昂发，在运行期，我们实际执行的是子类重写父类的方法</p>
<p>​	*直接：编译看左边，运行看右边</p>
<p>④多态性使用前提：①类的继承关系②方法的重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Charge</span> <span class="variable">charge1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QC</span>();</span><br><span class="line"><span class="type">Charge</span> <span class="variable">charge2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PD</span>();</span><br></pre></td></tr></table></figure>

<p>举例：type_c口，各厂家使用通用type-c接口（体现为Charge）,其内部使用自己的协议（体现为QC，PD）</p>
<p>⑤对象的多态性，只适用于方法不适用于属性。对于属性，还是父类的属性值（编译看左边，运行看左边）</p>
<p>方法的重载和重写：</p>
<p><img src="/../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221027224732342.png" alt="image-20221027224732342"></p>
<p>重载：早绑定或静态绑定</p>
<p>重写：多态，晚绑定或静态绑定</p>
<h3 id="调用子类方法"><a href="#调用子类方法" class="headerlink" title="调用子类方法"></a>调用子类方法</h3><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。若要调用，需要<em><strong>向下转型</strong></em>，即强制类型转换。</p>
<p>*当类型不能转换时，会报ClassCastException异常。</p>
<p>​	a instanceof A:判断a对象是否是类A的实例。是，返回true。不是返回false</p>
<p>​	instanceof 使用情形：为了避免在向下转型时出现ClassCastException异常，我们在向下转型之前，先进行instanceof 的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</p>
<p>​	如果a instanceof A返回true，则a instanceof B也返回true，其中类B是类A的父类。</p>
<p>正确：左边父类右边子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Woman</span> <span class="variable">w3</span> <span class="operator">=</span> (Woman)p3</span><br></pre></td></tr></table></figure>

<p>错误1：类型不一样，不能强转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Woman</span> <span class="variable">w3</span> <span class="operator">=</span> (Woman)p3;</span><br></pre></td></tr></table></figure>

<p>错误2：创建对象时内存中并没有新建加载Woman的东西，类型不一样，不能强转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Woman</span> <span class="variable">w3</span> <span class="operator">=</span> (Woman)p3;</span><br></pre></td></tr></table></figure>



<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>java.lang.Object类</p>
<p>①所有类的根父类</p>
<p>②如果在类的声明中未使用extends指明其父类，则默认父类为Object类</p>
<p>③Object类中声明的功能（属性，方法）具有通用性</p>
<p>④Object类只声明了一个空参的构造器</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="x3D-x3D-：运算符"><a href="#x3D-x3D-：运算符" class="headerlink" title="&#x3D;&#x3D;：运算符"></a>&#x3D;&#x3D;：运算符</h4><p>①可以使用在基本数据类型和引用数据类型变量中</p>
<p>②如果比较的是基本数据类型：比较两个变量保存是数据是否相等。（类型不一定要相同）</p>
<p>​	如果比较的是引用数据类型：比较两个对象的地址值是否相等。即两个引用是否指向同一个对象实体</p>
<h4 id="equals-：方法"><a href="#equals-：方法" class="headerlink" title="equals()：方法"></a>equals()：方法</h4><p>①是一个方法，而非运算符</p>
<p>②只能适用于引用数据类型</p>
<p>③Object类中定义的equals()和&#x3D;&#x3D;作用是一样的，即比较两个对象的地址值是否相等。即两个引用是否指向同一个对象实体</p>
<p>④像String，Date，File，包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体类容”是否相同</p>
<p>⑤通常情况下，我妈妈自定义类如果使用equals()的话，也通常是比较两个对象的”实体类容“是否相同。那么我们就需要对Object类中的equals()进行重写</p>
<p>举例：手动实现equals()，比较name和age是否相同<img src="/../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028162633457.png" alt="image-20221028162633457"></p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>①当我们输出一个对象的引用(对象名)时，实际上就是调用当前对象的toString()</p>
<p>②String，Date，File，包装类等都重写了Object类的toStirng()方法。使得在调用对象的toString()时，返回”实体内容“信息</p>
<p>③自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体类容”信息</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p><img src="/../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028184726322.png" alt="image-20221028184726322"><img src="/../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/image-20221028184615339.png" alt="image-20221028184615339"></p>
<h3 id="包装类的使用："><a href="#包装类的使用：" class="headerlink" title="包装类的使用："></a>包装类的使用：</h3><p>①Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</p>
<p>②掌握：基本数据类型，包装类，Stirng三者之间的转换</p>
<p>基本数据类型 —-&gt; 包装类：调用包装类的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -- -&gt; Integer</span></span><br><span class="line"><span class="comment">//toString可加可不加</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num1);</span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//带引号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，无法转换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123abc&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//同int</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);</span><br><span class="line">System.out.println(f1); <span class="comment">//12.3</span></span><br><span class="line">System.out.println(f2); <span class="comment">//12.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean ----&gt; Boolean</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);<span class="comment">//ture</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>包装类 —-&gt; 基本数据类型：调用包装类的xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer ----&gt; int</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> in1.intValue();</span><br><span class="line">System.out.println(i1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.3</span>);</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> f1.floatValue();</span><br><span class="line">System.out.println(f2);<span class="comment">//12.3</span></span><br></pre></td></tr></table></figure>

<h3 id="自动装箱与自动拆箱："><a href="#自动装箱与自动拆箱：" class="headerlink" title="自动装箱与自动拆箱："></a>自动装箱与自动拆箱：</h3><p>装箱：基本数据类型 —-&gt; 包装类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num1;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">method(num1);<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	System.out.method(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆箱：包装类 —-&gt; 基本数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num1;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> in1;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>



<p>*注意点：</p>
<p>Integer内部定义了IntegerCache结构，IntergerCache中定义了Integer[]，保存了从-128<del>127范围内的整数。如果我们用自动装箱的方式，给Integer赋值的范围在-128</del>127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.method(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.method(m == n);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.method(x == y);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>





<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="*单元测试"></a>*单元测试</h2><p>Junit单元测试</p>
<p>步骤：1.添加Junit依赖</p>
<p>2.创建Java类，进行单元测试。</p>
<p>​	此时的Java类要求：①此类是public的 ②此类提供公共的午餐构造器</p>
<p>3.此类中声明单元测试方法：方法的权限是public，没有返回值，没有形参</p>
<p>4.此单元测试方法上需要声明注解：@Test，并且在单元测试类中导入：import org.junit.Test</p>
<p>5.声明好单元测试后，就可以在方法体内测试相关代码</p>
<p>6.写完代码后，左键双击单元测试方法名，右键：run as - Junit Test</p>
<p>说明：①如果执行结果没有任何异常：绿条</p>
<p>②如果执行结果出现异常：红条</p>
<p>p315</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaSe/" rel="tag"># JavaSe</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/26/hexo%E9%85%8D%E5%90%88typora/" rel="prev" title="hexo配合typora的使用">
      <i class="fa fa-chevron-left"></i> hexo配合typora的使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/28/mysql%E5%AD%A6%E4%B9%A0/" rel="next" title="mysql学习">
      mysql学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">继承性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">1.1.</span> <span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected"><span class="nav-number">1.2.</span> <span class="nav-text">protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">1.3.</span> <span class="nav-text">super</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#super%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">super的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8-%E9%9A%BE"><span class="nav-number">1.3.2.</span> <span class="nav-text">super调用构造器(难)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">调用子类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.</span> <span class="nav-text">比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#x3D-x3D-%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.1.1.</span> <span class="nav-text">&#x3D;&#x3D;：运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">equals()：方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">toString()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">4.1.</span> <span class="nav-text">包装类的使用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">自动装箱与自动拆箱：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">5.</span> <span class="nav-text">*单元测试</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
